# Tic Tac Toe by adattoweb
Я реалізував гру "хрестики ноліки" повністю з нуля, використовуючи мову програмування Go. Зараз я розповім як це працює.  
## Загальна інструкція
Гра починається з того, що програма дає змогу обрати наступні параметри:  
1. З ким Ви будете грати (з ботом, чи з другом офлайн)  
2. Якщо з ботом, то обрати складність бота  
3. Обрати розмір поля  
4. Якщо з ботом, то обрати сторону  
Після цього, починається сама гра, де Вам треба обрати клітинку куди треба походити, наприклад, A1.  

## Як це влаштовано?
Спочатку створюється слайс довжиною size * size, наприклад, якщо ми візьмемо поле 4x4, то в size запишіться значення 4, а слайс буде довжиною 16 елементів.  
(Всі 16 елементів спочатку мають значення 0)  
Потім визначається значення гравця, якщо сторона гравця "O", то він буде 1, якщо "X", то 2.  
Створюються булеві зміні, які спочатку містять значення false, вони відповідають за те, яка сторона перемогла.  
Якщо значення бота == 1, тобто він нулик, то також само як і по правилам гри, він ходить перший.  
Починається цикл, який працює доти, поки одна зі сторін не виграє.  
Виводиться поле за допомогою функції getField, можна подивитись як вона влаштована:  
```Go
func getField(size int, array []int, arrayLetters [5]string){
    fmt.Printf("  ")
    for i := 0; i < size; i++ { // Виводимо буквочкі
        fmt.Printf(" %s", arrayLetters[i])
    }
    fmt.Printf("\n")
    for i := 0; i < len(array) / size; i++ { // виводимо поле
        fmt.Printf("%d:", i + 1) // циферкі по вертикалі
        for j := 0; j < size; j++ {
            print := "◻"
            if array[i * size + j] == 1 {
                print = "O"
            } else if array[i * size + j] == 2 {
	            print = "X"
            }
            fmt.Printf(" %s", print)
        }
        fmt.Printf("\n")
    }
}
```
Ось це виводить ця функція:  
![Pasted image 20250306102450](https://github.com/user-attachments/assets/118dfc86-30ed-44f3-be61-6b602b9af009)  
Далі програма запрошує координати куди гравець походить.  
Я не казав, але раніше ми створили масив:  
```Go
arrayLetters := [5]string{"A", "B", "C", "D", "E"}
```
Циклом ми проходимось по цьому масиву, і шукаємо першу букву відповіді гравця, уявимо гравець відповів A1, тоді в змінну indexLetter ми записуємо індекс A у масиві arrayLetters, тобто 0.  
Оскільки гравець вводить значення тип якого рядок, ми беремо другий символ з рядка A1 - 1, і конвертуємо "1" у цифру.  
Далі ми можемо побачити такий код:  
```go
isValid := false
if array[(num - 1) * size + indexLetter] == 0 {
	array[(num - 1) * size + indexLetter] = playerValue
    isValid = true;
```

Змінна isValid повідомляє нам чи успішно ми записали нове значення.  
Ми перевіряємо спочатку, куди гравець записує значення, там пусто, тобто чи не ходив туди хтось, якби хтось ходив, то було або 1, або 2.  
Потім, за допомогою функції checkWin, ми перевіряємо, чи призвів хід гравця до перемоги.  
Потім ходить бот, і також само перевіряємо чи переміг бот.  
Код функції checkWin доволі великий, тому якщо цікаво, раджу подивитись файл main.go, там є ця функція.  
Одразу скажу, спочатку може бути не зрозуміло що там відбувається, але якщо коротко, вона проходиться по масиву, який ми створювали раніше, шукає значення гравця (наприклад гравець має сторону "O", тоді в нього значення 1) і перевіряє, чи є місце, наприклад, зліва, щоб там помістились ще зайві 2 O, (тобто щоб вони були в один рядок, і не розривались), якщо так, то функція перевіряє чи дійсно там є O.  

Приблизно так працює програма.  

## Використані технології
- Мова програмування Go
- Пакет fmt
- Пакет strconv
- Пакет math/rand

